using SharpStix.Services;
using SharpStix.StixTypes;
using SharpStix.StixTypes.Vocabulary;

namespace SharpStix.StixObjects.Domain;

[StixTypeDiscriminator(TYPE)]
public sealed record MalwareAnalysis() : DomainObject()
{
    private const string TYPE = "malware-analysis";

    public MalwareAnalysis(MalwareResult result) : this()
    {
        Result = result;
    }

    public MalwareAnalysis(params StixIdentifier[] analysisScoRefs) : this()
    {
        AnalysisScoRefs = new List<StixIdentifier>(analysisScoRefs);
    }

    /// <summary>
    ///     The name of the analysis engine or product that was used. Product names SHOULD be all lowercase with words
    ///     separated by a dash "-".
    /// </summary>
    public required string Product { get; init; }

    /// <summary>
    ///     The version of the analysis product that was used to perform the analysis.
    /// </summary>
    public string? Version { get; init; }

    /// <summary>
    ///     A description of the virtual machine environment used to host the guest operating system (if applicable) that was
    ///     used for the dynamic analysis of the malware instance or family.
    /// </summary>
    public StixIdentifier? HostVmRef { get; init; }

    /// <summary>
    ///     The operating system used for the dynamic analysis of the malware instance or family. This applies to virtualized
    ///     operating systems as well as those running on bare metal.
    /// </summary>
    public StixIdentifier? OperatingSystemRef { get; init; }

    /// <summary>
    ///     Any non-standard software installed on the operating system (specified through the operating-system value) used for
    ///     the dynamic analysis of the malware instance or family.
    /// </summary>
    public List<StixIdentifier>? InstalledSoftwareRefs { get; init; }

    /// <summary>
    ///     The named configuration of additional product configuration parameters for this analysis run.
    /// </summary>
    public string? ConfigurationVersion { get; init; }

    /// <summary>
    ///     The specific analysis modules that were used and configured in the product during this analysis run.
    /// </summary>
    public List<string>? Modules { get; init; }

    /// <summary>
    ///     The version of the analysis engine or product (including AV engines) that was used to perform the analysis.
    /// </summary>
    public string? AnalysisEngineVersion { get; init; }

    /// <summary>
    ///     The version of the analysis definitions used by the analysis tool (including AV tools).
    /// </summary>
    public string? AnalysisDefinitionVersion { get; init; }

    /// <summary>
    ///     The date and time that the malware was first submitted for scanning or analysis. This value will stay constant
    ///     while the scanned date can change.
    /// </summary>
    public DateTime? Submitted { get; init; }

    /// <summary>
    ///     The date and time that the malware analysis was initiated.
    /// </summary>
    public DateTime? AnalysisStarted { get; init; }

    /// <summary>
    ///     The date and time that the malware analysis ended.
    /// </summary>
    public DateTime? AnalysisEnded { get; init; }

    /// <summary>
    ///     The classification result or name assigned to the malware instance by the scanner tool.
    /// </summary>
    public string? ResultName { get; init; }

    /// <summary>
    ///     The classification result as determined by the scanner or tool analysis process.
    /// </summary>
    public MalwareResult? Result { get; init; }

    /// <summary>
    ///     This property contains the references to the STIX Cyber-observable Objects that were captured during the analysis
    ///     process.
    /// </summary>
    public List<StixIdentifier>? AnalysisScoRefs { get; init; }

    /// <summary>
    ///     This property contains the reference to the SCO file, network traffic or artifact object that this malware analysis
    ///     was performed against.
    /// </summary>
    public StixIdentifier? SampleRef { get; init; }

    public override string Type => TYPE;
}